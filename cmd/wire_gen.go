// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package cmd

import (
	"encoding/json"
	"github.com/gorilla/mux"
	"github.com/jinzhu/gorm"
	"github.com/sirupsen/logrus"
	"github.com/spf13/viper"
	"github.com/kfajardo-agsx/kambal.git/internal/component/account"
	dropbox2 "github.com/kfajardo-agsx/kambal.git/internal/component/dropbox"
	"github.com/kfajardo-agsx/kambal.git/internal/component/file"
	minio2 "github.com/kfajardo-agsx/kambal.git/internal/component/minio"
	"github.com/kfajardo-agsx/kambal.git/internal/component/store"
	"github.com/kfajardo-agsx/kambal.git/internal/component/store_provider"
	"github.com/kfajardo-agsx/kambal.git/internal/component/tenant"
	"github.com/kfajardo-agsx/kambal.git/internal/entrypoint/api/rest"
	account2 "github.com/kfajardo-agsx/kambal.git/internal/entrypoint/api/rest/account"
	dropbox3 "github.com/kfajardo-agsx/kambal.git/internal/entrypoint/api/rest/dropbox"
	file2 "github.com/kfajardo-agsx/kambal.git/internal/entrypoint/api/rest/file"
	store2 "github.com/kfajardo-agsx/kambal.git/internal/entrypoint/api/rest/store"
	store_provider2 "github.com/kfajardo-agsx/kambal.git/internal/entrypoint/api/rest/store_provider"
	tenant2 "github.com/kfajardo-agsx/kambal.git/internal/entrypoint/api/rest/tenant"
	"github.com/kfajardo-agsx/kambal.git/internal/infrastructure/dropbox"
	"github.com/kfajardo-agsx/kambal.git/internal/infrastructure/minio"
	"github.com/kfajardo-agsx/kambal.git/internal/infrastructure/postgres"
	"github.com/kfajardo-agsx/kambal.git/internal/infrastructure/postgres/repository"
	"io/ioutil"
	"os"
	"strconv"
)

import (
	_ "github.com/lib/pq"
)

// Injectors from wire.go:

func createRestAPI() *rest.API {
	keys := ProvideKeysFromFile()
	config := ProvideRestAPIConfig(keys)
	router := mux.NewRouter()
	datasource := ProvideDatasource(keys)
	db := ProvideGormDB(datasource)
	tenantRepository := repository.NewTenantRepository(db)
	service := tenant.NewTenantService(tenantRepository)
	controller := tenant2.NewController(service)
	store_providerRepository := repository.NewStoreProviderRepository(db)
	store_providerService := store_provider.NewStoreProviderService(store_providerRepository)
	store_providerController := store_provider2.NewController(store_providerService)
	accountRepository := repository.NewAccountRepository(db)
	accountService := account.NewAccountService(accountRepository, service)
	accountController := account2.NewController(accountService)
	storeRepository := repository.NewStoreRepository(db)
	storeService := store.NewStoreService(storeRepository, service)
	storeController := store2.NewController(storeService)
	fileRepository := repository.NewFileRepository(db)
	dropboxConfig := ProvideDropboxConfig()
	dropboxClient := dropbox.NewService(dropboxConfig)
	dropboxService := dropbox2.NewDropboxService(dropboxClient, storeRepository)
	objectStore := minio.NewMinioStorage()
	minioService := minio2.NewMinioService(objectStore)
	fileService := file.NewFileService(fileRepository, storeService, accountService, dropboxService, minioService)
	context := ProvideFileContext()
	fileController := file2.NewController(fileService, context)
	dropboxController := dropbox3.NewController(dropboxService)
	api := rest.NewRestAPI(config, router, controller, store_providerController, accountController, storeController, fileController, dropboxController)
	return api
}

func createMigration() *postgres.Migration {
	keys := ProvideKeysFromFile()
	datasource := ProvideDatasource(keys)
	migration := postgres.NewMigration(datasource)
	return migration
}

// wire.go:

// this is where we wire all dependencies to run the API
type Keys struct {
	APIKey      string `json:"api-key"`
	S3AccessKey string `json:"s3-access-key"`
	S3SecretKey string `json:"s3-secret-key"`

	DBUsername string `json:"db-username"`
	DBPassword string `json:"db-password"`
}

func ProvideDatasource(keys *Keys) *postgres.Datasource {
	var datasource postgres.Datasource
	err := viper.UnmarshalKey("datasource", &datasource)
	if err != nil {
		logrus.WithError(err).Error("unable to read Datasource config")
		os.Exit(1)
	}
	datasource.Username = keys.DBUsername
	datasource.Password = keys.DBPassword
	return &datasource
}

func ProvideKeysFromFile() *Keys {
	file3 := viper.GetString("secrets.file")
	jsonFile, err := os.Open(file3)
	if err != nil {
		logrus.WithError(err).Error("unable to read security keys file")
		os.Exit(1)
	}
	defer jsonFile.Close()

	byteValue, _ := ioutil.ReadAll(jsonFile)
	var secrets Keys
	json.Unmarshal(byteValue, &secrets)

	return &secrets
}

func ProvideRestAPIConfig(keys *Keys) *rest.Config {
	var config rest.Config
	err := viper.UnmarshalKey("api.rest", &config)
	if err != nil {
		logrus.WithError(err).Error("unable to read RestAPIConfig")
		os.Exit(1)
	}

	rbacData, err := ioutil.ReadFile(config.Auth.RBACFile)
	if err != nil {
		logrus.WithError(err).Error("Error in reading RBAC data")
	}

	config.Auth.RBAC = string(rbacData)
	config.Auth.APIKey = keys.APIKey

	config.Version = root.Version
	logrus.Info("========================================")
	logrus.Info("API Configuration")
	logrus.Info("========================================")
	logrus.Info("Host:    ", config.Host)
	logrus.Info("Port:    ", config.Port)
	logrus.Info("Spec:    ", config.Spec)
	logrus.Info("Version: ", config.Port)
	logrus.Debugf("API Config: %+v", config)
	level := viper.GetBool("log.debug")
	if level {
		logrus.SetLevel(logrus.DebugLevel)
	}
	return &config
}

func ProvideGormDB(datasource *postgres.Datasource) *gorm.DB {
	db, err := gorm.Open("postgres", datasource.AsPQString())
	if err != nil {
		logrus.WithError(err).Error("unable to get gorm db connection")
		os.Exit(1)
	}
	return db
}

func ProvideDropboxConfig() *dropbox.Config {
	return &dropbox.Config{
		RedirectURI: viper.GetString("dropbox.redirectUri"),
		AuthURL:     viper.GetString("dropbox.auth.url"),
		ApiURL:      viper.GetString("dropbox.api.url"),
		ContentURL:  viper.GetString("dropbox.content.url"),
	}
}

func ProvideFileContext() *file.Context {
	mb, _ := strconv.Atoi(viper.GetString("file.max-upload-mb"))
	return &file.Context{
		MaxUploadMB: mb,
	}
}
